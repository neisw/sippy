package componentreadiness

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/openshift/sippy/pkg/api/componentreadiness/utils"
	"github.com/openshift/sippy/pkg/apis/api/componentreport/crview"
	v1 "github.com/openshift/sippy/pkg/apis/sippy/v1"
	"github.com/openshift/sippy/pkg/db"
	"github.com/openshift/sippy/pkg/db/models"
	"github.com/openshift/sippy/pkg/db/query"
	log "github.com/sirupsen/logrus"
	"gorm.io/gorm"
)

func GetTriage(dbc *db.DB, id int, baseURL string) (*models.Triage, error) {
	existingTriage := &models.Triage{}
	res := dbc.DB.Preload("Bug").Preload("Regressions").First(existingTriage, id)
	if res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		log.WithError(res.Error).Errorf("error looking up existing triage record: %d", id)
	}
	injectHATEOASLinks(existingTriage, baseURL)
	return existingTriage, res.Error
}

func ListTriages(dbc *db.DB, baseURL string) ([]models.Triage, error) {
	var triages []models.Triage
	var err error
	triages, err = query.ListTriages(dbc)
	for i := range triages {
		injectHATEOASLinks(&triages[i], baseURL)
	}
	return triages, err
}

func GetRegression(dbc *db.DB, id int, views []crview.View, releases []v1.Release, crTimeRoundingFactor time.Duration, baseURL string) (*models.TestRegression, error) {
	existingRegression := &models.TestRegression{}
	res := dbc.DB.Preload("Triages").First(existingRegression, id)
	if res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		log.WithError(res.Error).Errorf("error looking up existing regression record: %d", id)
	}
	InjectRegressionHATEOASLinks(existingRegression, views, releases, crTimeRoundingFactor, baseURL)
	return existingRegression, res.Error
}

func ListRegressions(dbc *db.DB, view, release string, views []crview.View, releases []v1.Release, crTimeRoundingFactor time.Duration, baseURL string) ([]models.TestRegression, error) {
	var regressions []models.TestRegression
	var err error
	regressions, err = query.ListRegressions(dbc, view, release)
	if err != nil {
		return regressions, err
	}

	// Add HATEOAS links to each regression
	for i := range regressions {
		InjectRegressionHATEOASLinks(&regressions[i], views, releases, crTimeRoundingFactor, baseURL)
	}

	return regressions, err
}

// validateTriage ensures the Triage record coming into the API appears valid. Small
// changes in logic for create vs update are controlled by the update param.
func validateTriage(triage models.Triage, update bool) error {
	create := !update
	if create && triage.ID > 0 {
		return fmt.Errorf("cannot specify an id for a new triage record, one will be autogenerated")
	}
	if update && triage.ID == 0 {
		return fmt.Errorf("must specify an id for a triage record update")
	}
	if triage.URL == "" {
		return fmt.Errorf("url is required for a triage record")
	}
	if !models.ValidTriageType(triage.Type) {
		return fmt.Errorf("invalid triage type: %s", triage.Type)
	}

	return nil
}

func CreateTriage(dbc *gorm.DB, triage models.Triage, baseURL string) (models.Triage, error) {
	err := validateTriage(triage, false)
	if err != nil {
		log.WithError(err).Error("error validating triage record")
		return triage, err
	}
	// zero out the timestamps, you shouldn't be specifying them, but it's not worth erroring a request over
	triage.CreatedAt = time.Time{}
	triage.UpdatedAt = time.Time{}

	err = linkRegressions(dbc, &triage)
	if err != nil {
		return triage, err
	}

	// If we have a bug in the db matching the url we were given, link them up now.
	// If not, this should be handled later during the next fetchdata cron job.
	var bug models.Bug
	res := dbc.Where("url = ?", triage.URL).First(&bug)
	switch {
	case res.Error != nil && !errors.Is(res.Error, gorm.ErrRecordNotFound):
		log.WithError(res.Error).Errorf("unexpected error looking up bug: %s", triage.URL)
		return triage, res.Error
	case res.Error == nil:
		triage.Bug = &bug
		triage.BugID = &bug.ID
	}

	res = dbc.Create(&triage)
	if res.Error != nil {
		log.WithError(res.Error).Error("error creating triage record")
		return triage, res.Error
	}
	log.WithField("triageID", triage.ID).Info("triage record created")

	injectHATEOASLinks(&triage, baseURL)
	return triage, nil
}

func linkRegressions(dbc *gorm.DB, triage *models.Triage) error {
	// We support linking to regressions by just setting the ID in the request, lookup
	// full regressions for association.
	regressionIDs := []uint{}
	for _, trIDR := range triage.Regressions {
		regressionIDs = append(regressionIDs, trIDR.ID)
	}
	var linkedRegressions []models.TestRegression
	res := dbc.Where("id IN ?", regressionIDs).Find(&linkedRegressions)
	if res.Error != nil {
		log.WithError(res.Error).Errorf("error looking up regression IDs: %v", regressionIDs)
		return res.Error
	}

	if len(linkedRegressions) != len(regressionIDs) {
		missing := []uint{}
		for _, ri := range regressionIDs {
			var found bool
			for _, lr := range linkedRegressions {
				log.Infof("got lr : %+v", lr)
				if lr.ID == ri {
					found = true
					break
				}
			}
			if !found {
				missing = append(missing, ri)
			}
		}
		err := fmt.Errorf("some of the requested regression IDs were not found: %v",
			missing)
		log.WithError(err).Error("error looking up test regressions during create")
		return err
	}
	triage.Regressions = linkedRegressions
	return nil
}

func UpdateTriage(dbc *gorm.DB, triage models.Triage, baseURL string) (models.Triage, error) {
	err := validateTriage(triage, true)
	if err != nil {
		log.WithError(err).Error("error validating triage record")
		return triage, err
	}

	// Ensure the record exists and preserve fields you're not allowed to update:
	// Side effect of not requiring you to specify them in your json.
	existingTriage := models.Triage{}
	res := dbc.First(&existingTriage, triage.ID)
	if res.Error != nil {
		log.WithError(res.Error).Errorf("error looking up existing triage record: %v", triage.ID)
		return triage, res.Error
	}
	triage.CreatedAt = existingTriage.CreatedAt

	err = linkRegressions(dbc, &triage)
	if err != nil {
		return triage, err
	}

	// If we have a bug in the db matching the url we were given, link them up now.
	// If not, this should be handled later during the next fetchdata cron job.
	var bug models.Bug
	res = dbc.Where("url = ?", triage.URL).First(&bug)
	switch {
	case res.Error != nil && !errors.Is(res.Error, gorm.ErrRecordNotFound):
		log.WithError(res.Error).Errorf("unexpected error looking up bug: %s", triage.URL)
		return triage, res.Error
	case res.Error == nil:
		triage.Bug = &bug
		triage.BugID = &bug.ID
	}

	// Use a transaction to handle both model update and association changes atomically
	// Gorm is unable to handle this in a single save operation when regressions are removed
	err = dbc.Transaction(func(tx *gorm.DB) error {
		// Capture the old triage state before making any changes, this is necessary to avoid multiple audit logs for the transaction
		var oldTriage models.Triage
		if err := tx.Preload("Regressions").First(&oldTriage, triage.ID).Error; err != nil {
			return err
		}
		ctx := context.WithValue(tx.Statement.Context, models.OldTriageKey, oldTriage)
		txWithContext := tx.WithContext(ctx)

		if err := txWithContext.Session(&gorm.Session{SkipHooks: true}).Model(&triage).Association("Regressions").Replace(triage.Regressions); err != nil {
			return err
		}

		return txWithContext.Save(&triage).Error
	})
	if err != nil {
		log.WithError(err).Error("error updating triage record and associations")
		return triage, err
	}

	injectHATEOASLinks(&triage, baseURL)
	return triage, nil
}

func DeleteTriage(dbc *gorm.DB, id int) error {
	existingTriage := &models.Triage{}
	res := dbc.First(existingTriage, id).Delete(existingTriage)
	if res.Error != nil {
		return fmt.Errorf("error deleting triage record: %v", res.Error)
	}
	return nil
}

// injectHATEOASLinks adds restful links clients can follow for this triage record.
func injectHATEOASLinks(triage *models.Triage, baseURL string) {
	if baseURL == "" {
		// For backward compatibility, return relative URL if no baseURL provided
		triage.Links = map[string]string{
			"self": fmt.Sprintf("/api/component_readiness/triages/%d", triage.ID),
		}
	} else {
		// Create fully qualified URL
		triage.Links = map[string]string{
			"self": fmt.Sprintf("https://%s/api/component_readiness/triages/%d", baseURL, triage.ID),
		}
	}
}

// InjectRegressionHATEOASLinks adds restful links clients can follow for this regression record.
func InjectRegressionHATEOASLinks(regression *models.TestRegression, views []crview.View, releases []v1.Release, crTimeRoundingFactor time.Duration, baseURL string) {
	if regression.Links == nil {
		regression.Links = make(map[string]string)
	}

	// Add self link with fully qualified URL
	regression.Links["self"] = fmt.Sprintf("https://%s/api/component_readiness/regressions/%d", baseURL, regression.ID)

	// Generate test details URL - use baseURL to create fully qualified URLs
	testDetailsURL, err := utils.GenerateTestDetailsURL(regression, baseURL, views, releases, crTimeRoundingFactor)
	if err != nil {
		log.WithError(err).Warnf("failed to generate test details URL for regression %d", regression.ID)
		// Still provide a basic link even if URL generation fails
		testDetailsURL = fmt.Sprintf("https://%s/api/component_readiness/test_details?testId=%s&baseRelease=%s&sampleRelease=%s",
			baseURL, regression.TestID, regression.Release, regression.Release)
	}

	regression.Links["test_details"] = testDetailsURL
}
