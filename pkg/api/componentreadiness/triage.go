package componentreadiness

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/openshift/sippy/pkg/db"
	"github.com/openshift/sippy/pkg/db/models"
	"github.com/openshift/sippy/pkg/db/query"
	log "github.com/sirupsen/logrus"
	"gorm.io/gorm"
)

func GetTriage(dbc *db.DB, id int) (*models.Triage, error) {
	existingTriage := &models.Triage{}
	res := dbc.DB.Preload("Bug").Preload("Regressions").First(existingTriage, id)
	if res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		log.WithError(res.Error).Errorf("error looking up existing triage record: %d", id)
	}
	injectHATEOASLinks(existingTriage)
	return existingTriage, res.Error
}

func ListTriages(dbc *db.DB) ([]models.Triage, error) {
	var triages []models.Triage
	var err error
	triages, err = query.ListTriages(dbc)
	for i := range triages {
		injectHATEOASLinks(&triages[i])
	}
	return triages, err
}

// validateTriage ensures the Triage record coming into the API appears valid. Small
// changes in logic for create vs update are controlled by the update param.
func validateTriage(triage models.Triage, update bool) error {
	create := !update
	if create && triage.ID > 0 {
		return fmt.Errorf("cannot specify an id for a new triage record, one will be autogenerated")
	}
	if update && triage.ID == 0 {
		return fmt.Errorf("must specify an id for a triage record update")
	}
	if triage.URL == "" {
		return fmt.Errorf("url is required for a triage record")
	}
	if !models.ValidTriageType(triage.Type) {
		return fmt.Errorf("invalid triage type: %s", triage.Type)
	}

	return nil
}

func CreateTriage(dbc *gorm.DB, triage models.Triage) (models.Triage, error) {
	err := validateTriage(triage, false)
	if err != nil {
		log.WithError(err).Error("error validating triage record")
		return triage, err
	}
	// zero out the timestamps, you shouldn't be specifying them, but it's not worth erroring a request over
	triage.CreatedAt = time.Time{}
	triage.UpdatedAt = time.Time{}

	err = linkRegressions(dbc, &triage)
	if err != nil {
		return triage, err
	}

	// If we have a bug in the db matching the url we were given, link them up now.
	// If not, this should be handled later during the next fetchdata cron job.
	var bug models.Bug
	res := dbc.Where("url = ?", triage.URL).First(&bug)
	switch {
	case res.Error != nil && !errors.Is(res.Error, gorm.ErrRecordNotFound):
		log.WithError(res.Error).Errorf("unexpected error looking up bug: %s", triage.URL)
		return triage, res.Error
	case res.Error == nil:
		triage.Bug = &bug
		triage.BugID = &bug.ID
	}

	res = dbc.Create(&triage)
	if res.Error != nil {
		log.WithError(res.Error).Error("error creating triage record")
		return triage, res.Error
	}
	log.WithField("triageID", triage.ID).Info("triage record created")

	injectHATEOASLinks(&triage)
	return triage, nil
}

func linkRegressions(dbc *gorm.DB, triage *models.Triage) error {
	// We support linking to regressions by just setting the ID in the request, lookup
	// full regressions for association.
	regressionIDs := []uint{}
	for _, trIDR := range triage.Regressions {
		regressionIDs = append(regressionIDs, trIDR.ID)
	}
	var linkedRegressions []models.TestRegression
	res := dbc.Where("id IN ?", regressionIDs).Find(&linkedRegressions)
	if res.Error != nil {
		log.WithError(res.Error).Errorf("error looking up regression IDs: %v", regressionIDs)
		return res.Error
	}

	if len(linkedRegressions) != len(regressionIDs) {
		missing := []uint{}
		for _, ri := range regressionIDs {
			var found bool
			for _, lr := range linkedRegressions {
				log.Infof("got lr : %+v", lr)
				if lr.ID == ri {
					found = true
					break
				}
			}
			if !found {
				missing = append(missing, ri)
			}
		}
		err := fmt.Errorf("some of the requested regression IDs were not found: %v",
			missing)
		log.WithError(err).Error("error looking up test regressions during create")
		return err
	}
	triage.Regressions = linkedRegressions
	return nil
}

func UpdateTriage(dbc *gorm.DB, triage models.Triage) (models.Triage, error) {
	err := validateTriage(triage, true)
	if err != nil {
		log.WithError(err).Error("error validating triage record")
		return triage, err
	}

	// Ensure the record exists and preserve fields you're not allowed to update:
	// Side effect of not requiring you to specify them in your json.
	existingTriage := models.Triage{}
	res := dbc.First(&existingTriage, triage.ID)
	if res.Error != nil {
		log.WithError(res.Error).Errorf("error looking up existing triage record: %v", triage.ID)
		return triage, res.Error
	}
	triage.CreatedAt = existingTriage.CreatedAt

	err = linkRegressions(dbc, &triage)
	if err != nil {
		return triage, err
	}

	// If we have a bug in the db matching the url we were given, link them up now.
	// If not, this should be handled later during the next fetchdata cron job.
	var bug models.Bug
	res = dbc.Where("url = ?", triage.URL).First(&bug)
	switch {
	case res.Error != nil && !errors.Is(res.Error, gorm.ErrRecordNotFound):
		log.WithError(res.Error).Errorf("unexpected error looking up bug: %s", triage.URL)
		return triage, res.Error
	case res.Error == nil:
		triage.Bug = &bug
		triage.BugID = &bug.ID
	}

	// Use a transaction to handle both model update and association changes atomically
	// Gorm is unable to handle this in a single save operation when regressions are removed
	err = dbc.Transaction(func(tx *gorm.DB) error {
		// Capture the old triage state before making any changes, this is necessary to avoid multiple audit logs for the transaction
		var oldTriage models.Triage
		if err := tx.Preload("Regressions").First(&oldTriage, triage.ID).Error; err != nil {
			return err
		}
		ctx := context.WithValue(tx.Statement.Context, models.OldTriageKey, oldTriage)
		txWithContext := tx.WithContext(ctx)

		if err := txWithContext.Session(&gorm.Session{SkipHooks: true}).Model(&triage).Association("Regressions").Replace(triage.Regressions); err != nil {
			return err
		}

		return txWithContext.Save(&triage).Error
	})
	if err != nil {
		log.WithError(err).Error("error updating triage record and associations")
		return triage, err
	}

	injectHATEOASLinks(&triage)
	return triage, nil
}

func DeleteTriage(dbc *gorm.DB, id int) error {
	existingTriage := &models.Triage{}
	res := dbc.First(existingTriage, id).Delete(existingTriage)
	if res.Error != nil {
		return fmt.Errorf("error deleting triage record: %v", res.Error)
	}
	return nil
}

// injectHATEOASLinks adds restful links clients can follow for this triage record.
func injectHATEOASLinks(triage *models.Triage) {
	triage.Links = map[string]string{
		"self": fmt.Sprintf("/api/component_readiness/triages/%d", triage.ID),
	}
}
